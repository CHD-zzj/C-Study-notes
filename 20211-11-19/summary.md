# c++学习

#### 前置递增与后置递增

前置递增是先递增后执行表达式

int a=10;

cout<<++a;//此时输出11

cout<<a;//此时输出11

后置递增是先执行表达式后进行递增

int b=10;

cout<<b++;//输出10

cout<<b;//输出11

### const的用法

指针常量 const修饰常量 ：int * const p=&a指针的指向不能改变

常量指针const修饰指针 ：const int *p=&a指针的指向可以改变，但指针指向的值不能改变

const既修饰常量又修饰指针：const int* const p=&a;指针指向和指向的值都不能改变

const修饰形参 防止对原变量进行修改

void show(const int &b);  

结构体中的const使用：如果函数调用是地址传递可以使用const防止误操作

比如对结构体student 的打印函数

Print(const student *s);

### 4区：

运行前就存在

代码区（存放二进制代码，由操作系统管理），特点：共享，只读。

全局区（全局变量和静态变量以及常量），包含常量区，程序结束后由操作系统释放

运行后才存在

栈区（由编译器自动分配与释放，存放函数参数值，局部变量等），

堆区（由程序员分配释放，若程序员不释放，程序结束时候由操作系统回收）//new与malloc会在这里

不在全局区中的：局部变量，const修饰的局部变量（局部常量）

全局区：全局变量，静态变量（static），常量（”字符串常量“，const修饰的全局变量（全局常量））

### new关键字

new返回的是对应类型的指针，所需要指针接收

int *p=new int[10]//new一个数组

手动释放使用delete 释放数组使用delete[]+数组名

int *p=new int (10)

### 引用 &

给变量起别名，引用必须初始化，并且初始化后不可以改变，引用的本质就是一个指针常量

int b;

int &a=b;//编译器会自动变成：  int *const a=&b

在函数中

引用传递与地址传递可以让形参修饰实参，值传递不可以修饰实参

引用还可以作为函数的返回值，但是不要返回局部变量的引用，因为局部变量在栈区，程序执行完毕就会自动释放掉，

int& test(){static int a=10;return a;}必须使用static关键字，让变量变为全局变量才可以返回引用

### 函数

函数重载的条件：1.同一个作用域下。2.函数名相同。3.函数类型不同，比如形参是否被const修饰，参数个数不同，顺序不同等等

函数形参可以有默认参数，占位参数（调用函数必须补全）

注意：返回值不能作为函数重载的条件，引用可以进行函数重载，重载碰到默认参数不能发生重载

### 类和对象

三大特性：封装，继承，多态

在c++中struct与class唯一区别在于默认的访问权限不同

struct默认为公共权限 public

class默认为私有

#### 封装

将属性与行为作为一个整体表现生活中的事务，并加以权限控转

使用class关键字设计类

三种访问权限

1.public 公共权限

类内类外都可以访问

2.protected 保护权限

类内可以访问，类外不可以访问

3.private私有权限

类内可以访问，类外不可以访问

private和protected的区别：在于继承的时候子类不可以访问父类的private属性，private私有属性是父类所特有的，儿子可以访问父亲的protected属性

#### 私有权限的好处

1.可以自己控转读写权限，对于写权限可以检测数据的有效性

# 对象的初始化与清理

---

## 构造函数与析构函数

自己可以写也可以不写，不写的时候编译器自动提供的是空实现函数，编译器自动调用

构造函数：主要用于创建对象时为对象的成员属性赋值，

析构函数：主要用于在对象销毁前系统自动调用，执行一些清理工作

### 构造函数语法：类名(){}

没有返回值也不用写void

函数名与类名相同

构造函数可以有参数，能够发生重载

调用对象时候会自动调用构造函数，且只会调用一次

### 析构函数语法：~类名(){}

没有返回值也不用写void

函数名与类名一样 +~

析构函数不能有参数，因此不可以发生重载

对象销毁自动调用，且只调用一次

---

# 构造函数的分类以及调用

按参数分类：有参构造与无参构造

按类型分类：普通构造与拷贝构造

三种调用方式：括号法，显示法，隐式转换法

#### 拷贝构造函数的使用时机

使用一个已经创建完毕的对象来初始化一个新对象

值传递的方式给函数参数传值

以值方式返回局部对象

值传递会拷贝一个副本

值传递方式给函数参数传值，值方式返回局部对象，都会调用拷贝构造函数

#### 构造函数的调用规则

创建一个类会默认添加三个函数

1.默认构造函数

如果用户定义了有参构造函数，则编译器不再提供默认无参构造函数，但会继续提供拷贝函数

如果用户定义了拷贝构造函数，则编译器不提供其他任何构造函数

2.默认析构函数

3.默认拷贝函数

#### 深/浅拷贝

浅拷贝是简单的赋值拷贝，容易造成内存的重复释放

深拷贝是在堆区重新申请空间进行拷贝操作，需要自己写拷贝构造函数

//类内有指针指向身高 如果析构函数通过delete释放申请的内存，则会导致删除同一片内存两次

//重复删除

Person(const int & p){

m.height=new int (* p.height)

}

#### 初始化列表

语法：构造函数():属性1（值1），属性2（值2）。。。。{}

#### c++允许类中成员可以是另一个类的对象，称该成员为对象成员

class A{}

class B{

​    	A a

}

B类中有对象A作为成员，则称A为对象成员

当其他类的对象作为本类成员，构造时先构造类对象，再构造自身

析构时先释放本类，再释放类对象，刚好与构造的时候相反

# 静态成员

静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员

静态成员分为：

## 1.静态成员变量 

所有对象共享同一份数据

在编译阶段分配内存（全局区）

类内声明，类外初始化

静态成员变量不属于某个对象上，因为所有对象共享同一份数据

所以静态成员变量有两种访问方式，

1.通过对象进行访问。

Person p;

p.m_A;

2.通过类名进行访问.

Person::m_A;

静态成员变量也有访问权限

### 2.静态成员函数

所有对象共享同一个函数

静态成员函数只能访问静态变量，非静态变量无法访问，因为static函数无法区分到底是哪个对象的成员

静态成员函数也有访问权限，

# c++this指针

1.在c++中成员变量与成员函数分开储存的，静态变量，非静态成员函数与静态成员函数都不属于类的成员

只有非静态变量才属于类的成员，其他都不算

注意：空对象的大小是1字节，用来区分空对象占内存的位置，每个空对象也有一个独一无二的内存地址

如果一个类中只有一个int型成员变量，则这个类的大小为4 并不是5

this指针指向 被调用的成员函数所属于的对象

哪个对象在调用this就指向哪个对象，返回对象本身用*this，this指针的本质是指针常量

# const修饰成员函数

## 常函数

常函数内不得修改成员属性，但是成员定义属性前＋mutable可以进行修改

void func（）const；本质上是修饰this指针，使得值不可修改，

mutable int B；可以修改B

## 常对象

const Person P；

不允许修改指针指向的值 

# 友元函数

友元函数有三种实现方式

1.全局函数

2.类

3.成员函数

成员函数与全局函数类似，复制函数名在名前加friend关键字

class A;

class B;

class A{

friend class B;//B是A的朋友

}

使用友元类时，需要注意：

​	友元关系不能被继承；

​	友元关系是单向的，不具有交换性。即类B是类A的友元，则类A不一定是类B的友元，需要看类中是否有相应的声明；

​	友元关系不具有传递性。即类B是类A的友元，类C是类B的友元，但类C不一定是类A的友元，需要看类中是否有相应的声明。

另外，使用一般不建议把整个类声明为友元类，而只将某些成员函数声明为友元函数，这样更安全些。

# 运算符重载

类名+operator+运算符+（参数）；实现对自定对象的运算符操作

### 左移运算符重载：<<可以输出任何类型数据

一般使用全局函数进行重载，成员函数会导致cout在<<右侧

cout数据类型为ostream，输入流对象’

重载时需要注意链式编程思想 ，使得能够连续进行<<，也就是说函数的返回值类型需要是ostream&

### 匿名函数对象

在当前行创建一个匿名对象，当前行执行结束就会被释放
